# 多线程的使用

## 一、stop、interrupt

```java
public void runTest() {
    Thread thread = new Thread() {
        @Override
        public void run() {
            for (int i = 0; i < 1_000_000; i++) {
                //if (Thread.interrupted()) {//条件成立之后会标记为false
                if (isInterrupted()) {//可以进行多次判断,如果已经中断了，会一直返回true
                    //已经被中断了就进入
                    //实战中要做收尾工作，退出循环，结束线程工作
                    return;
                }

                try {
                    Thread.sleep(1000);//模拟耗时操作
                } catch (InterruptedException e) {
                    //已经被中断了就进入
                    //实战中要做收尾工作，退出循环，结束线程工作
                    return;
                }
                System.out.println("number:"+i);
            }
        }
    };
    thread.start();
    try {
        Thread.sleep(10000);//模拟耗时操作
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    //thread.stop();//强制停止线程，导致处理结果不可控
    thread.interrupt();//相当于打一个标记，会让run函数内的代码跑完才结束，结果可控
}
```

终结：

stop();//强制停止线程，导致处理结果不可控
interrupt();//相当于打一个标记，会让run函数内的代码跑完才结束，结果可控



## 二、synchronized关键字、wait、notify、notifyAll

```java
private String mMessage;
private final Object monitor1 = new Object();

@Override
public void runTest() {
    Thread thread1 = new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                Thread.sleep(1000);//模拟耗时操作
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            printString();
        }
    });

    Thread thread2 = new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                Thread.sleep(2000);//模拟耗时操作
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            updateString();
        }
    });

    thread1.start();
    thread2.start();
    try {
        //相当于简化版的wait,不需要notify，只要thread1的printString()执行完，
        // 当前线程（主线程）才能继续往下执行
        thread1.join();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("end");
}

//wait、notifyAll必须要在同一个监视器里
//private synchronized void updateString() { //这种写法monitor默认是this
private void updateString() {
    synchronized (monitor1) {
        mMessage = "huangpengfei";
        //monitor1.notify();//只释放一个wait，不能全部解锁
        monitor1.notifyAll();//释放所有wait
    }

}
private synchronized void printString() {
    synchronized (monitor1) {
        if (mMessage == null) {
            try {
                monitor1.wait();
                //wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("mMessage = " + mMessage);
    }
}
```

